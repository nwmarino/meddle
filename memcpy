Exactly ‚Äî you‚Äôve got it. ‚úÖ

The primary purpose of alignment in a memcpy or similar operation is:

    To tell the compiler the largest data width it can safely move in one instruction.

Let‚Äôs break that down.
üîß What Does Alignment Really Mean Here?

If you know a memory address is aligned to N bytes, then:

    You are guaranteed that the address is a multiple of N (addr % N == 0)

    Therefore, you can safely use load/store instructions that operate on N bytes at a time

    On some architectures, unaligned access is illegal or traps; on others it‚Äôs just slow

üì¶ How Alignment Affects Codegen in memcpy

Assume:

memcpy(dst, src, len, dst_align=8, src_align=8);

This tells the compiler:

    Both src and dst are aligned to 8 bytes

    So it's safe to copy in 8-byte chunks

‚úÖ Codegen with alignment known:

// Copying 8 bytes at a time
mov rax, [rsi]         ; load 8 bytes
mov [rdi], rax         ; store 8 bytes

If you do 4 of these, you‚Äôve copied 32 bytes in just 8 instructions.
‚ùå Codegen when alignment is unknown or low:

If alignment is 1 (or unknown), then:

    You cannot use mov rax, [src] if src might not be 8-byte aligned

    On strict-alignment architectures (ARM, RISC-V), this traps

    Even on x86, it may fall back to microcoded unaligned moves, which are slower

So the backend must fall back to:

// Copying byte-by-byte
mov al, [rsi]
mov [rdi], al
...

This is much slower and less efficient.
‚ö†Ô∏è Why Two Alignments (src_align, dst_align)?

Because they can differ.
Example:
Scenario	src_align	dst_align	Implication
copying from packed struct to stack	1	8	Can read byte-by-byte, write 8-byte chunks
copying from aligned buffer to I/O-mapped memory	8	1	Must write byte-by-byte, but can read in big chunks
copying from and to heap	8	8	Full-speed copy using wide instructions

So the compiler can:

    Choose fastest safe path based on alignment

    Emit different-sized loads/stores based on the minimum of both alignments

üí° So in your IR:

When you specify:

memcpy %dst, %src, %len, dst_align=8, src_align=1

You‚Äôre telling the compiler:

    "You can write in 8-byte chunks, but you must read byte-by-byte or use unaligned reads."

That affects how it lowers the memcpy into real instructions.